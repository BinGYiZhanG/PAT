用两个栈实现，

(1) 初始化两个栈：运算符栈S1和储存中间结果的栈S2；
(2) 从右至左扫描中缀表达式；
(3) 遇到操作数时，将其压入S2；
(4) 遇到运算符时，比较其与S1栈顶运算符的优先级：
       (4-1) 如果S1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈；
       (4-2) 否则，若优先级比栈顶运算符的较高或相等，也将运算符压入S1；
       (4-3) 否则，将S1栈顶的运算符弹出并压入到S2中，再次转到(4-1)与S1中新的栈顶运算符相比较；
(5) 遇到括号时：
      (5-1) 如果是右括号“)”，则直接压入S1；
      (5-2) 如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃；
(6) 重复步骤(2)至(5)，直到表达式的最左边；
(7) 将S1中剩余的运算符依次弹出并压入S2；
(8) 依次弹出S2中的元素并输出，结果即为中缀表达式对应的前缀表达式。


```cpp
#include<iostream>
#include<stack>
#include<cstring>
#include<map>
using namespace std;

int main() {
	char express[100];
	stack<char> S1, S2;
	map<char, int> op;
	op['+'] = op['-'] = 1;
	op['*'] = op['/'] = 2;
	//cout<<"输入表达式： ";
	cin >> express;
	//cout<<"您输入了："<<express<<endl;

	char c;

	for (int i = strlen(express) - 1; i >= 0; i--) {
		c = express[i];
		if (c >= 'a' && c <= 'z')
			S1.push(c);

		else if (c == ')' || S2.empty() == 1 || S2.top() == ')') {
			S2.push(c);
		}

		else if (c == '(') {
			while (S2.top() != ')') {
				S1.push(S2.top());
				S2.pop();
			}
			S2.pop();
		}

		else {
			while (S2.empty() == 0 && op[c] < op[S2.top()]) {
				S1.push(S2.top());
				S2.pop();
			}
			S2.push(c);
		}
	}
	while (S2.empty() != 1) {
		S1.push(S2.top());
		S2.pop();
	}

	while (S1.empty() != 1) {
		cout << S1.top();
		S1.pop();
	}
	return 0;
}

```
