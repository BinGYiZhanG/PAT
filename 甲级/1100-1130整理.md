### 1101 Quick Sort (25 分)
题意：查询在数组满足条件 ```大于左边的元素，小于右边的元素``` 的元素数
* 注意格式输出，当不存在时，该如何输出
```
if(cnt==0){
        printf("\n");///注意格式输出
    }
```

### 1102 Invert a Binary Tree (25 分)
题意：交换二叉树的左右子树
后序查询交换左右子树
```
void postOrder(int root){
    if(root==-1)///一开始想不通为什么root是-1,
        return ;
    postOrder(nd[root].lchild);
    postOrder(nd[root].rchild);
    swap(nd[root].lchild,nd[root].rchild);
}
```

### 1103 Integer Factorization (30 分)
题意：输出满足$sum=a_{1}^{P}+a_{2}^{P}+...+a_{K}^{P}$
* DFS查找，有剪枝
* 其中计算$a_{x}^{P}$函数也写的不错
```
int power(int x){
  int ans=1;
  for(int i=0;i<p;i++)
    ans*=x;
  return ans;
}

void init(){
  int tmp=0,i=0;
  while(tmp<=n){
    fac.push_back(tmp);
//    temp.push_back(tmp);
    tmp=power(++i);
  }
}

void DFS(int index,int nowK,int sum,int facSum){
  if(sum==n&&nowK==k){
    if(facSum>maxfacSum){
      maxfacSum=facSum;
      ans=temp;
    }
    return ;
  }
  if(nowK>k||sum>n) return ;
  if(index-1>=0){
//if(index-1>0){
    temp.push_back(index);
    DFS(index,nowK+1,sum+fac[index],facSum+index);
    temp.pop_back();
    DFS(index-1,nowK,sum,facSum);
  }
}
```
