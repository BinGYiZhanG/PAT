结点U和结点V的最低公共祖先（LCA）是结点U和结点V作为后代的最深结点。<br>
一棵二叉查找树（BST）被递归定义，按如下条件：
* 结点的左子树只包含键值比结点的键值小的结点
* 右子树只包含大的
* 左右子树也都是二叉查找树

给出BST中的任意两个结点，你应该找到他们的LCA。<br>

### 输入
对于每个测试用例，<br>
* 第一行，M，需要测试的结点对数；N，BST中的结点数目。
* 第二行，N个整数被给出，这是BST的前序序列
* 接下来M行，每行包含结点U和V，所有键值```key```均是整数

### 输出
对于每对```U```和```V```，
* 打印```LCA of U and V is A```,如果LCA被找到，A是其键值。
* 如果```A```是```U```或者```V```的一个，那么打印```X is an ancestor of Y.```,X是A，Y是其他结点
* 如果```U```和```V```没有在BST中发现，打印```ERROR: U is not found. ```or```ERROR: V is not found.``` or ```ERROR: U and V are not found.```.


### 思路
* 结点的键值大于左子树，小于等于右子树
* 
